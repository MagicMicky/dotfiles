#!/usr/bin/env zsh
# Main zshrc - Modern shell configuration
# This file sources all configuration in the correct order

# Determine dotfiles location dynamically
# Resolve .zshrc symlink to find actual dotfiles directory
if [[ -L "${HOME}/.zshrc" ]]; then
  # .zshrc is symlinked - resolve to find dotfiles repo
  # readlink -f follows all symlinks to get the real path
  ZSHRC_REAL_PATH=$(readlink -f "${HOME}/.zshrc")
  # Go up two directories: /path/to/dotfiles/zsh/.zshrc -> /path/to/dotfiles
  DOTFILES_DIR=$(dirname $(dirname "$ZSHRC_REAL_PATH"))
else
  # Fallback to default location if .zshrc is not a symlink
  DOTFILES_DIR="${HOME}/Development/dotfiles"
fi

# Verify DOTFILES_DIR exists before proceeding
if [[ ! -d "$DOTFILES_DIR" ]]; then
  echo "ERROR: Dotfiles directory not found: $DOTFILES_DIR" >&2
  echo "Cannot load shell configuration" >&2
  if [[ -L "${HOME}/.zshrc" ]]; then
    echo "Note: .zshrc is symlinked from: $(readlink -f "${HOME}/.zshrc")" >&2
  else
    echo "Note: .zshrc is not symlinked. Expected symlink from dotfiles repo" >&2
  fi
  return 1
fi

# Source machine-specific environment (generated by Ansible at install time)
# This sets MACHINE_TYPE and Starship environment variables
if [[ -f ~/.config/shell/starship-env.zsh ]]; then
  source ~/.config/shell/starship-env.zsh
else
  echo "WARNING: Machine environment not configured. Run Ansible playbook to set up." >&2
  # Fallback to default
  export MACHINE_TYPE="personal"
fi

# Source core configuration (in order)
# Note: Machine type detection (00-detect.zsh) has been replaced by starship-env.zsh above
for config_file in ${DOTFILES_DIR}/zsh/core/*.zsh; do
  [[ -f "$config_file" ]] && source "$config_file"
done

# Source profile-specific configuration based on machine type (set at install time)
case "$MACHINE_TYPE" in
  personal|pro)
    # Load laptop profile (both personal and work laptops)
    for config_file in ${DOTFILES_DIR}/zsh/profiles/laptop/*.zsh; do
      [[ -f "$config_file" ]] && source "$config_file"
    done
    # Load pro profile for work laptops (additional work-specific configs)
    if [[ "$MACHINE_TYPE" == "pro" ]]; then
      for config_file in ${DOTFILES_DIR}/zsh/profiles/pro/*.zsh; do
        [[ -f "$config_file" ]] && source "$config_file"
      done
    fi
    ;;
  wsl)
    # Load WSL profile
    for config_file in ${DOTFILES_DIR}/zsh/profiles/wsl/*.zsh; do
      [[ -f "$config_file" ]] && source "$config_file"
    done
    ;;
  server)
    # Load server profile (minimal configuration for all server types)
    for config_file in ${DOTFILES_DIR}/zsh/profiles/server/*.zsh; do
      [[ -f "$config_file" ]] && source "$config_file"
    done
    ;;
  *)
    echo "WARNING: Unknown machine type '$MACHINE_TYPE'. Using default (personal)." >&2
    # Load laptop profile as fallback
    for config_file in ${DOTFILES_DIR}/zsh/profiles/laptop/*.zsh; do
      [[ -f "$config_file" ]] && source "$config_file"
    done
    ;;
esac

# Source work-specific config if present (from mac-playbook-work)
# This contains sensitive work configurations
if [[ -f ~/.zsh.d/zworkenv ]]; then
  source ~/.zsh.d/zworkenv
fi

# CRITICAL FIX: Initialize completion BEFORE Starship
# This is counter-intuitive but prevents Starship from interfering with completion width calculation
autoload -Uz compinit
setopt EXTENDEDGLOB
if [[ -n ${ZDOTDIR:-$HOME}/.zcompdump(#qN.mh+24) ]]; then
  compinit
else
  compinit -C
fi

# Initialize Starship prompt AFTER completion system
if command -v starship &> /dev/null; then
  # Use generated starship config (Ansible creates ~/.config/starship.toml with machine-specific colors)
  # If not found, fall back to dotfiles version
  if [[ -f ~/.config/starship.toml ]]; then
    export STARSHIP_CONFIG=~/.config/starship.toml
  elif [[ -f "${DOTFILES_DIR}/starship/starship.toml" ]]; then
    export STARSHIP_CONFIG="${DOTFILES_DIR}/starship/starship.toml"
  fi
  eval "$(starship init zsh)"

  # CRITICAL: Force prompt reset on every command
  # This recalculates prompt width to prevent character duplication
  autoload -Uz add-zsh-hook
  _starship_reset_prompt() {
    # Reset zsh line editor state
    zle && zle reset-prompt
    return 0
  }
  add-zsh-hook precmd _starship_reset_prompt
fi

# Initialize modern tools
# fzf - Fuzzy finder
if command -v fzf &> /dev/null; then
  # Load fzf key bindings and completion
  if [[ -f ~/.fzf.zsh ]]; then
    source ~/.fzf.zsh
  elif [[ -f /usr/share/doc/fzf/examples/key-bindings.zsh ]]; then
    source /usr/share/doc/fzf/examples/key-bindings.zsh
  fi

  if [[ -f /usr/share/doc/fzf/examples/completion.zsh ]]; then
    source /usr/share/doc/fzf/examples/completion.zsh
  fi

  # fzf configuration
  export FZF_DEFAULT_OPTS='--height 40% --layout=reverse --border'

  # Use fd if available for fzf
  if command -v fd &> /dev/null; then
    export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'
    export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    export FZF_ALT_C_COMMAND='fd --type d --hidden --follow --exclude .git'
  fi
fi

# zoxide - Smart directory jumper
if command -v zoxide &> /dev/null; then
  eval "$(zoxide init zsh)"
fi

# Print welcome message (optional, can be removed if annoying)
if [[ -o interactive ]]; then
  echo "ðŸš€ Modern shell loaded | Machine: $MACHINE_TYPE"
fi
