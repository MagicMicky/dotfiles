#!/usr/bin/env zsh
# Main zshrc - Vanilla baseline (Stage 0)
# This file sources all configuration in the correct order

# Determine dotfiles location dynamically
# Resolve .zshrc symlink to find actual dotfiles directory
if [[ -L "${HOME}/.zshrc" ]]; then
  # .zshrc is symlinked - resolve to find dotfiles repo
  # readlink -f follows all symlinks to get the real path
  ZSHRC_REAL_PATH=$(readlink -f "${HOME}/.zshrc")
  # Go up two directories: /path/to/dotfiles/zsh/.zshrc -> /path/to/dotfiles
  DOTFILES_DIR=$(dirname $(dirname "$ZSHRC_REAL_PATH"))
else
  # Fallback to default location if .zshrc is not a symlink
  DOTFILES_DIR="${HOME}/Development/dotfiles"
fi

# Verify DOTFILES_DIR exists before proceeding
if [[ ! -d "$DOTFILES_DIR" ]]; then
  echo "ERROR: Dotfiles directory not found: $DOTFILES_DIR" >&2
  echo "Cannot load shell configuration" >&2
  if [[ -L "${HOME}/.zshrc" ]]; then
    echo "Note: .zshrc is symlinked from: $(readlink -f "${HOME}/.zshrc")" >&2
  else
    echo "Note: .zshrc is not symlinked. Expected symlink from dotfiles repo" >&2
  fi
  return 1
fi

# Source machine-specific environment (generated by Ansible at install time)
# This sets MACHINE_TYPE and Starship environment variables
if [[ -f ~/.config/shell/starship-env.zsh ]]; then
  source ~/.config/shell/starship-env.zsh
else
  echo "WARNING: Machine environment not configured. Run Ansible playbook to set up." >&2
  # Fallback to default
  export MACHINE_TYPE="personal"
fi

# Source core configuration (in order)
for config_file in ${DOTFILES_DIR}/zsh/core/*.zsh; do
  [[ -f "$config_file" ]] && source "$config_file"
done

# Source profile-specific configuration based on machine type (set at install time)
case "$MACHINE_TYPE" in
  personal|pro)
    # Load laptop profile (both personal and work laptops)
    for config_file in ${DOTFILES_DIR}/zsh/profiles/laptop/*.zsh; do
      [[ -f "$config_file" ]] && source "$config_file"
    done
    # Load pro profile for work laptops (additional work-specific configs)
    if [[ "$MACHINE_TYPE" == "pro" ]]; then
      for config_file in ${DOTFILES_DIR}/zsh/profiles/pro/*.zsh; do
        [[ -f "$config_file" ]] && source "$config_file"
      done
    fi
    ;;
  wsl)
    # Load WSL profile
    for config_file in ${DOTFILES_DIR}/zsh/profiles/wsl/*.zsh; do
      [[ -f "$config_file" ]] && source "$config_file"
    done
    ;;
  server)
    # Load server profile (minimal configuration for all server types)
    for config_file in ${DOTFILES_DIR}/zsh/profiles/server/*.zsh; do
      [[ -f "$config_file" ]] && source "$config_file"
    done
    ;;
  *)
    echo "WARNING: Unknown machine type '$MACHINE_TYPE'. Using default (personal)." >&2
    # Load laptop profile as fallback
    for config_file in ${DOTFILES_DIR}/zsh/profiles/laptop/*.zsh; do
      [[ -f "$config_file" ]] && source "$config_file"
    done
    ;;
esac

# Source work-specific config if present (from mac-playbook-work)
# This contains sensitive work configurations
if [[ -f ~/.zsh.d/zworkenv ]]; then
  source ~/.zsh.d/zworkenv
fi

# Initialize vanilla zsh completion (NO customization)
autoload -Uz compinit
compinit

# NO Starship initialization - using system default prompt (%)
# See: _doc/vanilla-roadmap.md Stage 2 for prompt addition

# NO fzf integration - disabled for vanilla testing
# See: _doc/vanilla-roadmap.md Stage 4 for fzf re-enablement

# NO zoxide integration - disabled for vanilla testing
# See: _doc/vanilla-roadmap.md Stage 4 for modern tools

# Print welcome message (helps identify which config is loaded)
if [[ -o interactive ]]; then
  echo "ðŸ”§ Vanilla baseline loaded | Machine: $MACHINE_TYPE | Stage: 0"
fi
